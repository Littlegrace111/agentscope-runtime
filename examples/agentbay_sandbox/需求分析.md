# AgentBay 多沙箱智能体需求分析

## 📋 需求概述

开发一个智能体，智能体框架使用 **AgentScope**，模型使用 **DashScope**，智能体能够使用 AgentBay 的 **4 个 GUI 沙箱**（`code_latest` 没有操作画面，所以不算 GUI 沙箱）完成自动化任务。

## 🎯 核心目标

1. **智能体框架**: AgentScope
2. **模型服务**: DashScope（通义千问）
3. **沙箱环境**: AgentBay 的 4 个 GUI 沙箱
4. **功能要求**: 能够完成自动化任务
5. **前端界面**: Chat Kit 用于对话和显示 GUI 沙箱画面
6. **后端服务**: FastAPI 服务部署，包含 Agent 智能体实现

## 🔍 需求分解

### 1. AgentBay GUI 沙箱识别

根据文档和代码分析，AgentBay 提供 5 种镜像类型，其中 **4 个有 GUI 操作画面**：

| 镜像类型         | 镜像 ID          | 沙箱类                   | 是否有 GUI | 描述                                           |
| ---------------- | ---------------- | ------------------------ | ---------- | ---------------------------------------------- |
| **Linux 桌面**   | `linux_latest`   | `AgentbayLinuxSandbox`   | ✅ 是      | Linux 桌面环境，支持命令执行、文件操作         |
| **Windows 桌面** | `windows_latest` | `AgentbayWindowsSandbox` | ✅ 是      | Windows 桌面环境，支持应用程序管理、窗口操作   |
| **浏览器**       | `browser_latest` | `AgentbayBrowserSandbox` | ✅ 是      | 浏览器自动化环境，支持网页导航、交互           |
| **移动端**       | `mobile_latest`  | `AgentbayMobileSandbox`  | ✅ 是      | Android 移动设备环境，支持 UI 自动化、手势操作 |
| **代码执行**     | `code_latest`    | `AgentbayCodeSandbox`    | ❌ 否      | 纯代码执行环境，无可视化界面                   |

**结论**: 需要支持的前 4 个 GUI 沙箱为：

- `linux_latest` (Linux 桌面)
- `windows_latest` (Windows 桌面)
- `browser_latest` (浏览器)
- `mobile_latest` (移动端)

### 2. 技术栈要求

#### 2.1 智能体框架

- **AgentScope**: 多智能体框架
- **Agent 类型**: 建议使用 `ReActAgent`（推理-行动循环）
- **工具集成**: 使用 `Toolkit` 注册工具函数

#### 2.2 模型服务

- **DashScope**: 阿里云模型服务
- **模型选择**: `qwen-max` 或 `qwen-plus`（推荐 `qwen-max`）
- **Formatter**: `DashScopeChatFormatter`

#### 2.3 沙箱集成

- **已有沙箱类**: 工程已集成 5 个 `AgentbaySandbox` 子类
  - `AgentbayLinuxSandbox` (image_id: `linux_latest`)
  - `AgentbayWindowsSandbox` (image_id: `windows_latest`)
  - `AgentbayBrowserSandbox` (image_id: `browser_latest`)
  - `AgentbayMobileSandbox` (image_id: `mobile_latest`)
  - `AgentbayCodeSandbox` (image_id: `code_latest`) - 不使用（无 GUI）
- **沙箱服务**: `SandboxService` 和 `EnvironmentManager`
- **工具发现**: 使用每个沙箱的 `list_tools()` 方法动态获取可用工具
- **多沙箱管理**: 需要同时管理 4 个不同类型的 GUI 沙箱实例
- **GUI 画面获取**: 通过沙箱的截图工具（`screenshot`, `browser_screenshot`, `mobile_screenshot`）获取 GUI 画面

#### 2.4 前端技术栈

- **Chat Kit**: 聊天界面组件库（如 React/Vue + Chat UI 组件）
- **实时通信**: WebSocket 或 Server-Sent Events (SSE) 用于实时消息推送
- **GUI 画面显示**:
  - 支持显示多个沙箱的截图画面
  - 实时更新沙箱画面（轮询或推送）
  - 支持切换不同沙箱的画面视图
- **功能要求**:
  - 对话消息展示
  - 工具调用过程可视化
  - 沙箱画面实时预览
  - 多沙箱画面切换

#### 2.5 后端技术栈

- **Web 框架**: FastAPI
- **API 设计**: RESTful API + WebSocket/SSE 支持
- **智能体服务**: AgentScope Agent 封装为服务
- **异步处理**: 支持异步任务处理和流式响应
- **功能模块**:
  - 智能体对话接口
  - 沙箱管理接口
  - 截图获取接口
  - 工具调用接口
  - WebSocket/SSE 实时推送

### 3. 功能需求分析

#### 3.1 多沙箱管理

智能体需要能够：

- ✅ 同时创建和管理 4 个不同类型的 GUI 沙箱
- ✅ 根据任务需求选择合适的沙箱执行操作
- ✅ 在多个沙箱之间切换和协调
- ✅ 统一管理沙箱的生命周期（创建、使用、释放）

#### 3.2 工具能力映射

每个沙箱提供的工具能力：

**Linux 沙箱** (`linux_latest`):

- 文件操作: `read_file`, `write_file`, `list_directory`, `create_directory`, `move_file`, `delete_file`
- 命令执行: `run_shell_command`, `run_ipython_cell`
- 截图: `screenshot` (如果有桌面环境)

**Windows 沙箱** (`windows_latest`):

- 文件操作: `read_file`, `write_file`, `list_directory`, `create_directory`, `move_file`, `delete_file`
- 命令执行: `run_shell_command`
- 桌面自动化: `start_app`, `stop_app`, `input_text`, `window_maximize`, `window_minimize`
- 截图: `screenshot`

**Browser 沙箱** (`browser_latest`):

- 文件操作: `read_file`, `write_file`, `list_directory`
- 浏览器基础操作: `browser_navigate`, `browser_click`, `browser_input`
- AI 驱动操作: `browser_agent_navigate`, `browser_agent_act`, `browser_agent_extract`, `browser_agent_observe`
- 截图: `browser_screenshot`

**Mobile 沙箱** (`mobile_latest`):

- 文件操作: `read_file`, `write_file`, `list_directory`
- UI 交互: `mobile_click`, `mobile_swipe`, `mobile_input_text`, `mobile_send_key`
- 应用管理: `mobile_start_app`, `mobile_stop_app`
- 截图: `mobile_screenshot`

#### 3.3 智能体决策能力

智能体需要具备：

- **任务理解**: 理解用户自然语言任务描述
- **沙箱选择**: 根据任务类型自动选择合适的沙箱
- **工具调用**: 在选定的沙箱上调用相应的工具
- **结果整合**: 整合多个沙箱的执行结果
- **错误处理**: 处理沙箱操作失败的情况

### 4. 系统架构设计

#### 4.0 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        前端 Chat Kit                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  对话界面    │  │  GUI画面显示 │  │ 沙箱管理面板 │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                          ↕ HTTP/WebSocket
┌─────────────────────────────────────────────────────────────┐
│                    FastAPI 后端服务                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  API路由层   │  │  Agent服务层 │  │ 沙箱管理层   │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────────┐
│                  AgentScope 智能体层                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ ReActAgent   │  │   Toolkit    │  │ 多沙箱管理器 │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────────┐
│              AgentBay 沙箱层（4个GUI沙箱）                   │
│  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐                   │
│  │Linux │  │Windows│ │Browser│ │Mobile│                   │
│  └──────┘  └──────┘  └──────┘  └──────┘                   │
└─────────────────────────────────────────────────────────────┘
```

### 5. 架构设计建议

#### 5.1 多沙箱管理器

```python
from agentscope_runtime.sandbox.box.agentbay import (
    AgentbayLinuxSandbox,
    AgentbayWindowsSandbox,
    AgentbayBrowserSandbox,
    AgentbayMobileSandbox,
)
from agentscope_runtime.engine.services.sandbox_service import SandboxService
from agentscope_runtime.engine.services.environment_manager import (
    create_environment_manager,
)
from agentscope_runtime.sandbox.enums import SandboxType

class MultiSandboxManager:
    """管理多个 AgentBay 沙箱实例"""

    def __init__(self, agentbay_api_key: str):
        self.sandboxes = {
            'linux': None,
            'windows': None,
            'browser': None,
            'mobile': None
        }
        self.sandbox_service = SandboxService(bearer_token=agentbay_api_key)
        self.environment_manager = None

    async def initialize_all_sandboxes(self):
        """初始化所有 4 个 GUI 沙箱"""
        # 使用 EnvironmentManager 创建多个沙箱
        self.environment_manager = await create_environment_manager(
            sandbox_service=self.sandbox_service,
        ).__aenter__()

        # 创建 4 个不同类型的 GUI 沙箱
        # 注意：需要通过指定不同的 image_id 来创建不同类型的沙箱
        sandboxes = self.environment_manager.connect_sandbox(
            session_id="multi_sandbox_session",
            user_id="multi_sandbox_user",
            env_types=[
                SandboxType.AGENTBAY.value,  # 需要为每个类型创建实例
            ],
        )

        # 根据 image_id 或 sandbox 类型分配到对应的字典
        # 注意：需要确保每个沙箱使用正确的 image_id
        pass

    def get_sandbox(self, sandbox_type: str):
        """获取指定类型的沙箱"""
        return self.sandboxes.get(sandbox_type)

    def get_all_tools(self) -> Dict[str, List[str]]:
        """获取所有沙箱的工具列表"""
        tools = {}
        for sandbox_type, sandbox in self.sandboxes.items():
            if sandbox:
                tools[sandbox_type] = sandbox.list_tools()
        return tools

    async def cleanup_all_sandboxes(self):
        """清理所有沙箱资源"""
        if self.environment_manager:
            self.environment_manager.release_sandbox(
                "multi_sandbox_session",
                "multi_sandbox_user",
            )
            await self.environment_manager.__aexit__(None, None, None)
```

#### 5.2 工具注册策略

**核心思路**: 使用每个沙箱的 `list_tools()` 方法动态获取工具，然后注册到 AgentScope 的 Toolkit

**方案 A: 统一工具接口（推荐）**

- 遍历所有 4 个 GUI 沙箱，调用每个沙箱的 `list_tools()` 获取工具列表
- 为每个工具创建统一的工具函数，函数内部路由到对应的沙箱实例
- 工具函数命名规则：`{sandbox_type}_{tool_name}` (如 `linux_run_shell_command`)
- 智能体通过工具名称即可调用，无需关心底层沙箱

**方案 B: 动态工具选择**

- 智能体在调用工具时指定沙箱类型参数
- 工具函数根据沙箱类型参数路由到对应的沙箱实例
- 工具名称可以更简洁（如 `run_shell_command`），但需要传入 `sandbox_type` 参数

**推荐实现流程**:

1. 初始化 4 个 GUI 沙箱实例
2. 对每个沙箱调用 `list_tools()` 获取工具列表
3. 为每个工具创建包装函数，调用对应沙箱的 `call_tool()` 方法
4. 将所有工具注册到 AgentScope 的 Toolkit
5. 智能体通过 Toolkit 使用这些工具

#### 5.3 智能体系统提示词设计

系统提示词需要包含：

- 可用的 4 个沙箱类型及其能力说明
- 如何根据任务选择合适的沙箱
- 每个沙箱支持的工具列表
- 多沙箱协作的场景和策略

#### 5.4 后端 API 设计

**FastAPI 路由结构**:

```python
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# CORS 配置（允许前端访问）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应限制具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 智能体对话接口
@app.post("/api/chat")
async def chat(message: str, session_id: str):
    """发送消息给智能体，返回回复"""
    pass

@app.get("/api/chat/stream")
async def chat_stream(message: str, session_id: str):
    """流式对话接口（SSE）"""
    pass

@app.websocket("/ws/chat")
async def websocket_chat(websocket: WebSocket):
    """WebSocket 实时对话"""
    pass

# 沙箱管理接口
@app.post("/api/sandboxes")
async def create_sandbox(sandbox_type: str):
    """创建指定类型的沙箱"""
    pass

@app.get("/api/sandboxes")
async def list_sandboxes():
    """获取所有沙箱列表"""
    pass

@app.get("/api/sandboxes/{sandbox_id}/screenshot")
async def get_screenshot(sandbox_id: str):
    """获取沙箱截图（Base64 编码）"""
    pass

@app.get("/api/sandboxes/{sandbox_id}/tools")
async def list_tools(sandbox_id: str):
    """获取沙箱可用工具列表"""
    pass
```

#### 5.5 前端组件设计

**主要组件结构**:

```
ChatKit/
├── ChatInterface/          # 对话界面
│   ├── MessageList/        # 消息列表
│   ├── InputBox/           # 输入框
│   └── ToolCallDisplay/    # 工具调用展示
├── SandboxViewer/          # 沙箱画面显示
│   ├── ScreenshotView/     # 截图视图
│   ├── SandboxSelector/    # 沙箱选择器
│   └── RefreshButton/      # 刷新按钮
└── SandboxManager/         # 沙箱管理面板
    ├── SandboxList/        # 沙箱列表
    └── SandboxStatus/      # 沙箱状态
```

### 6. 实现步骤

#### 阶段 1: 后端基础框架搭建

1. ✅ 创建多沙箱管理器类（基于 SandboxService 和 EnvironmentManager）
2. ✅ 实现 4 个 GUI 沙箱的初始化逻辑
   - 使用 `SandboxService` 创建沙箱服务
   - 使用 `EnvironmentManager` 管理沙箱生命周期
   - 为每个沙箱类型指定正确的 `image_id`
3. ✅ 集成 AgentScope 和 DashScope

#### 阶段 2: 工具发现与注册

1. ✅ 遍历所有沙箱，调用 `list_tools()` 获取工具列表
2. ✅ 为每个工具创建包装函数
   - 包装函数调用对应沙箱的 `call_tool()` 方法
   - 统一工具返回格式（ToolResponse）
3. ✅ 将所有工具注册到 AgentScope 的 Toolkit
   - 使用 `toolkit.register_tool_function()` 注册
   - 提供清晰的工具描述，帮助智能体理解工具用途

#### 阶段 3: 智能体开发

1. ✅ 设计系统提示词
   - 说明可用的 4 个沙箱类型及其能力
   - 说明工具命名规则和如何选择沙箱
2. ✅ 配置 ReActAgent
   - 使用 DashScope 模型
   - 传入包含所有工具的 Toolkit
3. ✅ 实现任务执行流程

#### 阶段 4: 后端 API 开发

1. ✅ 实现 FastAPI 路由和接口
2. ✅ 实现 WebSocket/SSE 实时通信
3. ✅ 实现截图获取和推送机制
4. ✅ 实现对话历史管理

#### 阶段 5: 前端开发

1. ✅ 搭建前端项目框架
2. ✅ 实现 Chat Kit 对话界面
3. ✅ 实现 GUI 画面显示组件
4. ✅ 实现沙箱管理面板
5. ✅ 集成 WebSocket/SSE 实时通信

#### 阶段 6: 前后端联调

1. ✅ 接口联调测试
2. ✅ 实时通信测试
3. ✅ 截图推送测试
4. ✅ 多沙箱切换测试

#### 阶段 7: 测试与优化

1. ✅ 编写测试用例
2. ✅ 测试多沙箱切换场景
3. ✅ 优化错误处理和资源管理
4. ✅ 性能优化（截图频率、响应速度等）

### 7. 示例任务场景

#### 场景 1: 跨平台文件操作

- **任务**: "在 Linux 沙箱中创建一个文件，然后在 Windows 沙箱中读取它"
- **涉及沙箱**: Linux + Windows
- **挑战**: 跨沙箱数据传递

#### 场景 2: Web 自动化 + 桌面操作

- **任务**: "打开浏览器访问某个网站，截图保存到 Windows 桌面"
- **涉及沙箱**: Browser + Windows
- **挑战**: 数据在沙箱间传递

#### 场景 3: 移动端测试 + 桌面分析

- **任务**: "在移动端启动某个应用并截图，然后在 Linux 沙箱中分析截图"
- **涉及沙箱**: Mobile + Linux
- **挑战**: 截图数据传递和分析

#### 场景 4: 全平台协作

- **任务**: "在浏览器中抓取数据，在 Linux 中处理数据，在 Windows 中生成报告，在移动端查看报告"
- **涉及沙箱**: Browser + Linux + Windows + Mobile
- **挑战**: 多沙箱协调和数据流管理

### 8. 关键技术挑战

#### 8.1 数据传递

- **问题**: 不同沙箱之间的数据如何传递？
- **方案**:
  - 使用文件系统（如果沙箱共享存储）
  - 通过 AgentScope 消息传递
  - 使用临时存储服务

#### 8.2 沙箱选择策略

- **问题**: 智能体如何知道选择哪个沙箱？
- **方案**:
  - 在系统提示词中明确说明各沙箱能力
  - 使用工具描述帮助模型理解
  - 支持智能体询问或尝试

#### 8.3 资源管理

- **问题**: 如何高效管理 4 个沙箱的生命周期？
- **方案**:
  - 延迟初始化（按需创建）
  - 统一的生命周期管理
  - 超时和错误恢复机制

#### 8.4 并发控制

- **问题**: 多个沙箱是否可以并发操作？
- **方案**:
  - 支持异步并发操作
  - 使用 asyncio 管理并发
  - 注意资源限制和 API 限流

#### 8.5 实时画面更新

- **问题**: 如何实时获取和推送沙箱 GUI 画面？
- **方案**:
  - 工具调用后自动触发截图获取
  - 使用 SSE 或 WebSocket 推送截图到前端
  - 前端定时轮询截图接口（备选方案）
  - 控制截图频率，避免性能问题

#### 8.6 前后端通信

- **问题**: 如何实现前后端实时通信？
- **方案**:
  - 对话消息：使用 WebSocket 双向通信
  - 截图推送：使用 SSE 单向推送
  - 工具调用状态：通过 WebSocket 实时推送
  - 错误处理：统一的错误响应格式

### 9. 与现有代码的关系

#### 9.1 已有实现

- ✅ `AgentbayLinuxSandbox` - Linux 沙箱实现
- ✅ `AgentbayWindowsSandbox` - Windows 沙箱实现
- ✅ `AgentbayBrowserSandbox` - Browser 沙箱实现
- ✅ `AgentbayMobileSandbox` - Mobile 沙箱实现
- ✅ `agentscope_use_agentbay_sandbox.py` - 单沙箱示例

#### 9.2 需要新增

- ❌ 多沙箱管理器类（基于已有的 SandboxService 和 EnvironmentManager）
- ❌ 多沙箱工具注册逻辑（使用 `list_tools()` 动态获取工具）
- ❌ 多沙箱智能体示例（集成 AgentScope + DashScope）
- ❌ 跨沙箱数据传递机制（通过 AgentScope 消息或临时存储）
- ❌ 工具路由机制（将工具调用路由到正确的沙箱实例）

### 10. 验收标准

#### 10.1 功能验收

- [ ] 能够同时创建和管理 4 个 GUI 沙箱
- [ ] 智能体能够根据任务选择合适的沙箱
- [ ] 智能体能够在不同沙箱上执行相应操作
- [ ] 支持跨沙箱的数据传递和协作
- [ ] 能够正确清理所有沙箱资源

#### 10.2 性能验收

- [ ] 沙箱初始化时间 < 30 秒
- [ ] 工具调用响应时间 < 5 秒
- [ ] 支持并发操作多个沙箱

#### 10.3 稳定性验收

#### 10.4 前端验收

- [ ] 对话界面流畅，支持流式输出
- [ ] GUI 画面能够实时更新
- [ ] 支持切换查看不同沙箱画面
- [ ] 工具调用过程可视化清晰
- [ ] 错误提示友好明确

#### 10.5 后端验收

- [ ] API 接口响应正常
- [ ] WebSocket/SSE 连接稳定
- [ ] 截图获取和推送正常
- [ ] 支持并发请求处理
- [ ] 错误处理和日志记录完善

- [ ] 错误处理完善，不会因单个沙箱失败导致整体崩溃
- [ ] 资源清理完整，不会泄漏沙箱资源
- [ ] 支持超时和重试机制

## 📝 总结

这个需求的核心是开发一个**多沙箱协调智能体**，它能够：

1. 理解用户任务
2. 选择合适的 GUI 沙箱
3. 在多个沙箱上执行操作
4. 整合结果并完成任务

### 关键技术要点

1. **使用已有沙箱类**: 不需要直接集成 `wuying-agentbay-sdk`，工程已提供 5 个 `AgentbaySandbox` 子类
2. **动态工具发现**: 使用每个沙箱的 `list_tools()` 方法动态获取可用工具列表
3. **工具注册**: 将获取到的工具注册到 AgentScope 的 Toolkit，供智能体使用
4. **沙箱管理**: 通过 `SandboxService` 和 `EnvironmentManager` 统一管理 4 个 GUI 沙箱的生命周期

### 关键挑战

- **沙箱选择策略**: 智能体如何根据任务选择合适的沙箱
- **数据传递机制**: 不同沙箱之间的数据如何传递
- **资源管理**: 如何高效管理 4 个沙箱的生命周期
- **工具路由**: 如何将工具调用路由到正确的沙箱实例

### 推荐方案

采用**统一工具接口**的方案：

- 工具命名规则：`{sandbox_type}_{tool_name}` (如 `linux_run_shell_command`)
- 通过工具名称即可识别目标沙箱
- 底层自动路由到对应的沙箱实例
- 智能体无需关心底层实现细节
